---
title: "Benchmarking 'collections'"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Benchmarking 'collections'}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The goal of this document is to compare the performances of some of the existing packages.
See [benchmark.Rmd](https://github.com/randy3k/collections/blob/master/vignettes/benchmark.Rmd) for the details.

We are comparing these packages with `collections`.

- [dequer](https://CRAN.R-project.org/package=dequer)
    `r packageDescription("dequer")$Version`
- [datastructures](https://CRAN.R-project.org/package=datastructures )
    `r packageDescription("datastructures")$Version`
- [liqueueR](https://CRAN.R-project.org/package=liqueueR)
    `r packageDescription("liqueueR")$Version`
- [hash](https://CRAN.R-project.org/package=hash)
    `r packageDescription("hash")$Version`
- [hashmap](https://CRAN.R-project.org/package=hashmap)
    `r packageDescription("hashmap")$Version`
- [fastmap](https://CRAN.R-project.org/package=fastmap)
    `r packageDescription("fastmap")$Version`
- Base R [implementation](https://github.com/randy3k/collections/blob/master/vignettes/baseR.R)


```{r global_options, include=FALSE}
requireNamespace("bench")
library(tidyverse)
options(digits = 3)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
source("baseR.R")
```

## Queue

```{r queue, echo = FALSE, cache = TRUE}
bench::press(
    n = c(50, 100, 500, 1000),
    bench::mark(
        `dequer::queue` = {
            q <- dequer::queue()
            pushback <- dequer::pushback
            pop <- dequer::pop
            x <- rnorm(n)
            for (i in 1:n) pushback(q, x[i])
            for (i in 1:n) pop(q)
        },
        `datastructures::queue` = {
            q <- datastructures::queue()
            insert <- datastructures::insert
            pop <- datastructures::pop
            x <- rnorm(n)
            for (i in 1:n) insert(q, x[i])
            for (i in 1:n) pop(q)
        },
        `liqueueR::Queue` = {
            q <- liqueueR::Queue$new()
            x <- rnorm(n)
            for (i in 1:n) q$push(x[i])
            for (i in 1:n) q$pop()
        },
        `base R` = {
            q <- Queue()
            x <- rnorm(n)
            for (i in 1:n) q$push(x[i])
            for (i in 1:n) q$pop()
        },
        `collections::Queue` = {
            q <- collections::Queue()
            x <- rnorm(n)
            for (i in 1:n) q$push(x[i])
            for (i in 1:n) q$pop()
        },
        check = FALSE
    )) %>%
    mutate(expression = fct_reorder(as.character(expression), median, .desc = TRUE)) %>%
    ggplot(aes(x = n, y = median)) +
    geom_line(aes(color = expression)) +
    scale_colour_brewer(palette = "Set2", direction = -1) +
    ggtitle("push and pop n times") + ylab("time")
```

# Stack

```{r stack, echo = FALSE, cache = TRUE}
bench::press(
    n = c(50, 100, 500, 1000),
    bench::mark(
        `dequer::stack` = {
            q <- dequer::stack()
            push <- dequer::push
            pop <- dequer::pop
            x <- rnorm(n)
            for (i in 1:n) push(q, x[i])
            for (i in 1:n) pop(q)
        },
        `datastructures::stack` = {
            q <- datastructures::stack()
            insert <- datastructures::insert
            pop <- datastructures::pop
            x <- rnorm(n)
            for (i in 1:n) insert(q, x[i])
            for (i in 1:n) pop(q)
        },
        `liqueueR::Stack` = {
            q <- liqueueR::Stack$new()
            x <- rnorm(n)
            for (i in 1:n) q$push(x[i])
            for (i in 1:n) q$pop()
        },
        `base R` = {
            q <- Stack()
            x <- rnorm(n)
            for (i in 1:n) q$push(x[i])
            for (i in 1:n) q$pop()
        },
        `collections::Stack` = {
            q <- collections::Stack()
            x <- rnorm(n)
            for (i in 1:n) q$push(x[i])
            for (i in 1:n) q$pop()
        },
        check = FALSE
    )) %>%
    mutate(expression = fct_reorder(as.character(expression), median, .desc = TRUE)) %>%
    ggplot(aes(x = n, y = median)) +
    geom_line(aes(color = expression)) +
    scale_colour_brewer(palette = "Set2", direction = -1) +
    ggtitle("push and pop n times") + ylab("time")
```


# Deque

```{r deque, echo = FALSE, cache = TRUE}
bench::press(
    n = c(50, 100, 500, 1000),
    bench::mark(
        `dequer::deque` = {
            q <- dequer::deque()
            push <- dequer::push
            pop <- dequer::pop
            popback <- dequer::popback
            x <- rnorm(n)
            for (i in 1:n) push(q, x[i])
            for (i in 1:floor(n / 2)) {
                pop(q)
                popback(q)
            }
        },
        `base R` = {
            q <- Deque()
            x <- rnorm(n)
            for (i in 1:n) q$push(x[i])
            for (i in 1:floor(n / 2)) {
                q$pop()
                q$popleft()
            }
        },
        `collections::Stack` = {
            q <- collections::Deque()
            x <- rnorm(n)
            for (i in 1:n) q$push(x[i])
            for (i in 1:floor(n / 2)) {
                q$pop()
                q$popleft()
            }
        },
        check = FALSE
    )) %>%
    mutate(expression = fct_reorder(as.character(expression), median, .desc = TRUE)) %>%
    ggplot(aes(x = n, y = median)) +
    geom_line(aes(color = expression)) +
    scale_colour_brewer(palette = "Set2", direction = -1) +
    ggtitle("push and pop n times") + ylab("time")
```


# Priority Queue

```{r priority_queue, echo = FALSE, cache = TRUE}
bench::press(
    n = c(50, 100, 500, 1000),
    bench::mark(
        `liqueueR::PriorityQueue` = {
            q <- liqueueR::PriorityQueue$new()
            x <- rnorm(n)
            p <- sample.int(n, n, replace = TRUE)
            for (i in 1:n) q$push(x[i], p[i])
            for (i in 1:n) q$pop()
        },
        `datastructures::binomial_heap` = {
            q <- datastructures::binomial_heap(key.class = "integer")
            insert <- datastructures::insert
            pop <- datastructures::pop
            x <- rnorm(n)
            p <- sample.int(n, n, replace = TRUE)
            for (i in 1:n) insert(q, p[i], x[i])
            for (i in 1:n) pop(q)
        },
        `collections::PriorityQueue` = {
            q <- collections::PriorityQueue()
            x <- rnorm(n)
            p <- sample.int(n, n, replace = TRUE)
            for (i in 1:n) q$push(x[i], p[i])
            for (i in 1:n) q$pop()
        },
        check = FALSE
    )) %>%
    mutate(expression = fct_reorder(as.character(expression), median, .desc = TRUE)) %>%
    ggplot(aes(x = n, y = median)) +
    geom_line(aes(color = expression)) +
    scale_colour_brewer(palette = "Set2", direction = -1) +
    ggtitle("push and pop n times") + ylab("time")
```


## Dict / hashmap

```{r dict, echo = FALSE, cache = TRUE}
bench::press(
    n = c(50, 100, 500, 1000),
    bench::mark(
        `datastructures::hashmap` = {
            h <- datastructures::hashmap()
            insert <- datastructures::insert
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) insert(h, k[i], x[i])
            for (i in sample(1:n)) h[k[i]]
        },
        `hash::hash` = {
            h <- hash::hash()
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) h[[k[i]]] <- x[i]
            for (i in sample(1:n)) h[[k[i]]]
        },
        `hashmap::hashmap` = {
            h <- hashmap::hashmap(keys = character(0), values = numeric(0))
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) h[[k[i]]] <- x[i]
            for (i in sample(1:n)) h[[k[i]]]
        },
        `fastmap::fastmap` = {
            h <- fastmap::fastmap()
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) h$set(k[i], x[i])
            for (i in sample(1:n)) h$get(k[i])
        },
        `base R` = {
            h <- Dict()
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) h$set(k[i], x[i])
            for (i in sample(1:n)) h$get(k[i])
        },
        `collections::Dict` = {
            h <- collections::Dict()
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) h$set(k[i], x[i])
            for (i in sample(1:n)) h$get(k[i])
        },
        check = FALSE
    )) %>%
    mutate(expression = fct_reorder(as.character(expression), median, .desc = TRUE)) %>%
    ggplot(aes(x = n, y = median)) +
    geom_line(aes(color = expression)) +
    scale_colour_brewer(palette = "Set2", direction = -1) +
    ggtitle("set and get n times") + ylab("time")
```


## Ordered Dict

It is not a fair benchmark as OrderedDict is built on top of Dict. We are interested in the extra over head in OrderedDict.

```{r ordered_dict, echo = FALSE, cache = TRUE}
bench::press(
    n = c(50, 100, 500, 1000),
    bench::mark(
        `base R` = {
            h <- OrderedDict()
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) h$set(k[i], x[i])
            for (i in sample(1:n)) h$get(k[i])
        },
        `collections::Dict` = {
            h <- collections::Dict()
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) h$set(k[i], x[i])
            for (i in sample(1:n)) h$get(k[i])
        },
        `collections::OrderedDict` = {
            h <- collections::OrderedDict()
            x <- rnorm(n)
            k <- as.character(seq_len(n))
            for (i in 1:n) h$set(k[i], x[i])
            for (i in sample(1:n)) h$get(k[i])
        },
        check = FALSE
    )) %>%
    mutate(expression = fct_reorder(as.character(expression), median, .desc = TRUE)) %>%
    ggplot(aes(x = n, y = median)) +
    geom_line(aes(color = expression)) +
    scale_colour_brewer(palette = "Set2", direction = -1) +
    ggtitle("set and get n times") + ylab("time")
```
